// 백준_DP_15990번_실버2_1,2,3 더하기 5 문데
// DP의 bottom - top 방식으로 문제를 해결했다.
// 연속해서 같은 숫자 금지 조건을 뺏을때의 점화식 : dp[i] = dp[i-1] + dp[i-2] + dp[i-3] 인데
// 해당 문제는 같은 수가 연속으로 나오면 안된다는 조건이 있다.
// 따라서, 마지막에 1이 오는경우, 2가 오는경우, 3이 오는경우로 나눠서 계산해준다.
// 점화식 : dp[i][1] = dp[i-1][2] + dp[i-1][3];
//			dp[i][2] = dp[i-2][1] + dp[i-2][3];
//			dp[i][3] = dp[i-3][1] + dp[i-3][2];
#include<iostream>

using namespace std;

long long dp[100001][4];

long long kk = 1000000009;



// dp[n][1] 마지막숫자가 1일때 합하여 n을 만드는 가짓수
int main() {

	int T;
	int n;

	cin >> T;


	// 1부터 3까지는 직접 세팅해준다.
	dp[1][1] = 1;
	//dp[2][1] = dp[1][2] + dp[1][3];
	dp[2][2] = 1;

	dp[3][1] = 1;
	dp[3][2] = 1;
	dp[3][3] = 1;

	// 4부터는 점화식 사용
	for (int i = 4; i <= 100000; i++) {
		// bottom - top 방식으로 점점 dp를 채워나간다.
		dp[i][1] = dp[i - 1][2] + dp[i - 1][3];
		dp[i][2] = dp[i - 2][1] + dp[i - 2][3];
		dp[i][3] = dp[i - 3][1] + dp[i - 3][2];


		// 세 값들의 크기가 모두 kk 보다 크거나 같아질때 한번씩 나머지 계산을 해준다.
		// long long 의 숫자 범위가 넘어가는것을 방지
		if (dp[i][1] >= kk && dp[i][2] >= kk && dp[i][3] >= kk) {
			dp[i][1] %= kk;
			dp[i][2] %= kk;
			dp[i][3] %= kk;
		}
	}

	//cout << dp[100000][1] << " " << dp[100000][2] << '\n';
	for (int i = 0; i < T; i++) {
		cin >> n;
		// 세 값의 합이 kk를 넘길 수 있으므로 마지막으로 한번 더 kk의 나머지계산을 해준다.
		cout << (dp[n][1] + dp[n][2] + dp[n][3])%kk << '\n';
	}


	return 0;
}