// 백준_DP_9465번_실버1_스티커 문제
// DP의 bottom - top 방식으로 풀어냈다.
// 핵심은 1. 해당열에서 스티커를 떼지 않았을 때,
//		  2. 해당열의 1행에서 스티커를 떼어냈을 때,
//		  3. 해당열의 2행에서 스티커를 떼어냈을 때 
//	의 최대 점수이다.


#include<iostream>
#include<algorithm>

using namespace std;

long long dp[3][100001];
int arr[3][100001];
int main() {

	int T;
	int n;

	cin >> T;

	for (int i = 0; i < T; i++) {
		cin >> n;
		for (int j = 1; j <= n; j++) {
			cin >> arr[1][j];
		}

		for (int j = 1; j <= n; j++) {
			cin >> arr[2][j];
		}

		// dp[0][x] = 아무것도 안뜯었을때
		// dp[1][x] = 위에 스티커를 뜯었을 때
		// dp[2][x] = 아래 스티커를 뜯었을 때
		dp[0][1] = 0;
		dp[1][1] = arr[1][1];
		dp[2][1] = arr[2][1];

		for (int i = 2; i <= n; i++) {
			// 아무것도 뜯지 않았을때, 최대값은 직전 열까지의 최대값이므로 직전의 각 행을 뽑은 dp를 비교
			dp[0][i] = max(dp[1][i - 1], dp[2][i - 1]);
			// 첫번째 행의 스티커를 뜯었을때, (직전에 뜯지 않은 경우 + 현재 스티커)와 (직전에 두번째행을 뽑은 dp값에 현재 스티커 점수를 합한 값) 비교
			dp[1][i] = max(dp[0][i - 1]+arr[1][i], dp[2][i - 1] + arr[1][i]);
			// 두번째 행의 스티커를 뜯었을때, (직전에 뜯지 않은 경우 + 현재 스티커)와 (직전에 첫번째 행을 뽑은 dp값에 현재 스티커 점수를 합한 값) 비교
			dp[2][i] = max(dp[0][i - 1]+arr[2][i], dp[1][i - 1] + arr[2][i]);
		}

		// 마지막 열의 세 dp값을 비교해 최대값을 출력
		cout << max({ dp[0][n], dp[1][n], dp[2][n] });
		cout << '\n';

	}

	

	return 0;
}