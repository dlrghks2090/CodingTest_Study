// 백준_정수론 및 조합론_11051번_실버1_이항 계수 2 문제
// 이항계수  =  n! / (k!(n-k)!)
// 파스칼의 법칙을 사용하여 overflow를 피한다.
//	[N K] + [N K+1] = [N+1 K+1]   =>   [N K] = [N-1 K-1] + [N-1 K]
// 동적 프로그래밍(DP)을 사용하여 문제를 푼다.
#include<iostream>

using namespace std;

int dp[1001][1001] = { 0 };

int main() {

	int N, K;

	dp[1][1] = 1;
	dp[1][0] = 1;

	cin >> N >> K;



	for (int i = 2; i <= N; i++) {
		for (int j = 0; j <= K; j++) {
			if (j == 0 || j == i) {
				dp[i][j] = 1;
			}
			else {
				// 결국 구하고자하는 값은 하위 수들의 합이므로 아랫단계부터 10007의 나머지를 계산하여 메모리의 크기를 줄인다.
				dp[i][j] = dp[i - 1][j - 1] % 10007 + dp[i - 1][j] % 10007;
			}
		}
	}


	// 위에서 구한 합해진 수들이 10007보다 커졌을 경우가 있으므로 다시한번 10007의 나머지를 구하는 계산을 해준다.
	cout << dp[N][K] % 10007;


	return 0;
}